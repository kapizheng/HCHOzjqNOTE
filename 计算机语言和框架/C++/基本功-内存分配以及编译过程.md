### 1、描述内存分配方式以及他们的区别

- 当进程运行的时候，操作系统会给该进程分配一段虚拟地址。在linux32位机上一般是2的32次方也就是4GB。
- 从低地址到高地址的分类有：
- 不可访问区，例如空指针一般是存放0的地址，当访问该地址一般是会报错的，因为0地址不可访问。
- 代码区也就是.text地址，用来存放代码。
- 常量存储区也就是.rodata，用来存放常量字符串。
- 静态存储区里面一般分为两个部分，第一个是.data指的是已经初始化了同时初始值不为0，另外一个是.bss是指未初始化的值，一般.bss会在进程开始的时候初始化为0，所以static变量一开始都为0。
- 接下来是堆，一般被malloc，new所用
- 然后是共享库的映射区域，如DLL或者SO库
- 栈区域
- 命令行参数和环境变量
- 操作系统内核区域，是多个进程共享的。

### 2、函数的调用过程

- 先将参数从右到左压入栈中。
- 然后将下一个指令的地址压入栈中。
- 然后再将ebp赋值给esp
- 之后跳帧esp给新函数开辟空间。
- Call，让PC计数器的指针改变。
- 之后执行函数内容
- 将ebp赋值给esp释放空间
- pop ebp给获得原函数的起始地址
- 之后进行ret，使得PC计数器指到原函数的下一个指令。

### 3、编译过程

- 预编译：让#开头的命令转换，例如#define，除了#pragma ，可以修改入口函数

- 编译：gcc，g++，语法分析，语义分析，代码优化，生成汇编代码。
- 汇编：生成二进制可重定位的目标文件。符号表的输出。`g++ -S`

`objdump -t main.o`

打印符号表表示该文件中各种符号的属性，或者说在程序运行过程中字符所存放的位置，例如main放在.text（代码段）j静态为初始化放在.bss段上，初始化全局变量放在.data上。同时会定义其范围如static一般定义为local，没有static为global，是否为引用。

`objdump  -S main.o`

可以查看汇编指令

`readelf -h main.o`

查看文件头，如文件大小，入口地址等。。

.o文件是由ELF文件头，.text.data.bss等段构建

编译过程中，符号是不分配虚拟地址的。

- 链接：ld -e main *

1、将各种段合并如.data合并.data。2、进行符号解析：找到符号定义的地方，没找到，多找到都会报错。3、符号重定向，要给符号分配地址。

4、生成progma header 文件头中间有两个LOAD告诉系统程序运行的时候将哪些内内容加载到内存中，主要是加载代码段和数据段。8

### 4、可执行文件的执行过程

程序将.text等段映射到进程的虚拟地址空间上，当访问这些地址没访问到的时候，就发送缺页异常。