### 1、const在C和C++的区别有哪些

- const的编译方式不同，在c中就是当作一个变量来编译指令的。C++中所有出现const变量名字的地方，都被常量的初始化替换了。

`const int a=b`叫做常变量，因为初始值不是立即数而是变量。可以通过对其取地址进行修改。 

## 2、C++和C之间互相调用

C++调用C：把C函数声明扩在extern "C"里面

C调用C++：把C++源码扩在extern “C”里面

### 3、const和指针

- 指针常量：int * const p;//指针本身是常量

- 常量指针：const int * p;//指针所指的内容是常量

- 指针在const右边不参与类型转换，也就是顶层const会被忽略。

#### 4、左值引用和右值引用

左值：有内存，有名字，值可以修改。

右值：没内存，没名字，直接放在寄存器上，不可修改。

1. 两个&&专门用来引用右值类型，指令上，可以自动生成临时量，然后直接引用临时量C=40;

2. 一个右值引用变量本身是一个左值，只能用左值引用引用它
3. 不能用右值变量引用左值。

### 5、new和delete和malloc和free

- malloc和free为C的库函数
- new和delete称为运算符
- new和delete会调用构造和析构函数
- new错误了会抛出异常，malloc会返回NULL

### 6、函数模板

- 函数模板，无法进行编译，因为类型不知道

  ```c++
  template<typename T>
  bool compare(T a,T b)//函数模板 
  {
  	return a>b;
  } 
  ```

- 模板的实例化

  在函数的调用点实例化

  ```C++
  std::cout<<compare<int>(1,2);
  ```

- 模板函数

  函数实例化所生成的函数，这个才会被编译器编译。

- 模板类型参数

- 模板非类型参数  

  为const类型，不能被改变

  ```
  template<typename T,int SIZE>
  void sort(T *arr)
  {
  	for(int i=0;i<SIZE-1;++i){
  		for(int j=0;j<SIZE-1-i;++j){
  			if(arr[j]>arr[j+1]){
  				int tmp=arr[j];
  				arr[j]=arr[j+1];
  				arr[j+1]=tmp;
  			}
  		}
  	}
  }
  sort<int,2>(arr);
  std::cout<<arr[0]<<" "<<arr[1];
  ```

  

- 模板实参推演

  可以根据用户传入的实参类型，来推导模板类型的具体类型实现。

  ```C++
  std::cout<<compare(1,2);
  ```

- 模板的特例化

  不是编译器提供的，而是开发者提供的函数。

  ```c++
  template<>
  bool compare(const char *a,const char *b)//函数模板 
  {
  	return strcmp(a,b);
  } 
  ```

- 非模板函数

  ```C++
  bool compare(const char *a,const char *b)//函数模板 
  {
  	return strcmp(a,b);
  } 
  ```

- 函数模板，模板的特例化，非模板函数的重载关系

  编译器先去找非模板函数，再找函数模板实例化，再找函数模板

- 模板代码是不能在一个文件中定义，在另外一个文件中使用，模板代码调用之前，一定要看到模板定义的地方，这样的话，模板才能进行正常的实例化，产生能够被编译器编译的代码。

  所以，模板代码都说放在头文件当中的，然后用`#include<>`

### 7、空间配置器

- 内存开辟/内存释放   对象构造/对象析构

需要讲内存开辟/内存释放和对象构造/对象析构分开，防止对象pop_back的时候没有释放对应的外部资源。

### 8、new和delete

- 检查内存泄漏的方案之一：重载operator new 和operator delete

