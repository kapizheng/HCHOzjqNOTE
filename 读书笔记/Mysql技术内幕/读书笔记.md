# 第二章 innodb存储引擎

## 1、innodb的体系架构

- 数据结构，磁盘数据，重做日志缓冲等。
- Master thread负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性。
- IO thread大量使用了AIO异步IO来处理IO请求，有四种不同的线程。
- Purge thread，用来回收undo页。
- 内存
  - 缓冲池，查询和更新主要先在缓冲池中进行。
  - LRU List，Free List，Flush List管理缓冲池。
    - LRU中有一个教midpoint的位置。当读取到新页的时候，是放到这个位置上，目的是为了防止扫描操作将缓冲池中最经常使用的页面移出。
  - 重做日志缓冲
    - innodb首先将重做日志信息先放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件。
      - Mater thread每一秒会将重做日志缓冲刷新到日志文件。
      - 每个事务提交的时候将重做日志缓冲刷新到重做日志文件。
      - 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。
  - 额外的内存池

## 2、checkpoint技术

- Write Ahead Log，在事务提交时，先写重做日志，再修改页。
- 目的：缩短数据库恢复时间，缓冲池不够用时，将脏页刷新到磁盘，重做日志不可用时，刷新脏页。

## 3、Mater Thread工作方式

- 内部有多个循环
- Loop，主循环，大多数操作是在这个循环中，其中有两大部分的操作，每秒操作和每10秒操作。
  - 每秒：日志缓冲刷新到磁盘中，即使这个事务还没提交。合并插入缓冲，至多刷新100个innodb缓冲池的脏页到磁盘中。如果当前没有用户活动，则切换到background loop。
  - 每10秒：刷新100个脏页到磁盘，合并至多5个插入缓冲，将日志缓冲刷新到磁盘，删除无用的undo页，刷新100个或者10个脏页到磁盘（该操作得看脏页占比）
- background loop
  - 删除无用的undo页
  - 合并20个插入缓冲
  - 跳回主循环
  - 不断刷新100个页直到符合条件。

## 4、Innodb关键特性

- 插入缓冲（提升性能）
  - 插入的B+树其索引是辅助索引同时索引不是唯一的。也就是每次插入的时候插入到一个缓冲池中。假如缓冲池中没有改索引，就先放入到一个insertBuffer对象中。
  - 为什么不要唯一的，假如是唯一的话，就必须跑去数据库查看该数据是不是唯一的，这样子就失去了缓冲的意义。
  - 该数据结构是B+树，该结构的非叶子节点包含该插入语句所操作的页信息（space,offset)。还有一个marker用来兼容老版本。
  - 叶子节点信息出了非叶子的信息外还多出了一个metada，该信息保存着该语句的插入顺序等。
  - Insert Buffer Bitma页是用来追踪辅助索引页。
    - 辅助索引页被读取到缓冲池的时候。
    - 合并的时候，内存少了就强制进行一个合并。
    - Master thread10秒回给一次操作。
- 两次写（提升数据可靠性）
  - 当一个DML语句发送的同时，数据库宕机了。这个时候没法通过日志对数据进行恢复，因为其本来的数据已经是错误的了。
  - 当触发脏页刷新的时候，先将数据刷新到内存中的double write buffer中。
    - 接着数据分两次写入磁盘共享表空间中。
    - 写完后，再将double write buffer中的数据写入实际的各个表空间文件中。
  - 当系统崩溃的时候，系统会从磁盘共享表空间中去找到该页的一个最近的副本，将其复制到表空间文件，再用redolog，完成了恢复过程。
  - 副作用，造成磁盘负载
- 自适应哈希索引
  - innodb自动检查各索引的查询频率，假如频率过高就自动建立哈希索引。
- 异步IO
- 刷新邻接页
  - 每次刷新看看隔壁是不是脏的。

# 第二章 文件

## 28、日志

- 错误日志：启动、运行、关闭的时候的记录。
- 慢查询日志：通过该日志可以查询到哪些语句运行比较慢，从而排查哪些语句出错。
- 查询日志：记录了所有对Mysql数据库请求的信息。
- 二进制日志：记录了对mysql数据库执行更改的所有操作。
  - 恢复，复制，审计（防止MySQL注入）

## 27、数据库的表空间

- 一个表是由：段->区（固定1MB）->页（默认16KB）组成的。页有时候被叫做块。
- 表空间是innodb存储引擎的最高层。可以通过参数`innodb_file_per_table`将表区分到不同的文件中去。每个文件只包含：表数据、索引和插入缓冲Bitmap页。对于二次写缓冲，回滚，插入缓冲索引页，系统事务信息等还是放在原来的共享表空间中去。

### 第五章 索引与算法

- 联合索引和覆盖索引
  - 覆盖索引不止可以防止回表查询，还可以减少聚合操作的次数，如count(*)
- 为了防止回表操作
  - 有时候会没有选择非聚集索引
- 索引提示的索引不一定最后会被采用。
- MRR优化，是将非聚集索引中的索引放入缓存，排序之后再统一查找。
- （ICP）索引下推技术可以在非聚集索引的查询过程中进行判断
- 全文检索的原理是建立倒排索引，innodb后来的版本中在磁盘中拥有一个持久化的辅助表和在内存中有一个红黑树结构来存储倒排索引。

### 第六章 锁

- latch和lock

  - latch是轻量级锁，要求锁定的时间要短，它包括读写锁，互斥锁。
  - latch是用在线程安全的，保护线程的临界资源
  - lock的对象是事务，保护的是数据库资源

- innodb支持lock的共享锁和排它锁，他们都是行级锁

- innodb还有意向锁这种东西，这种锁的颗粒比较大，是在表上的。

- 一致性非锁定读

  - 一致性非锁定读不需要进行加锁操作，而是当读取了一个加锁的操作后，去读取该数据的历史版本。也就是快照读。
  - 快照读在不同的隔离级别下有不同的意思，同时，快照读采用的是MVCC模式。
  - 在RC的情况下，每次读取都是已经提交的数据，而在RR的情况下，每次读取都是事务开始时候的数据。

- 一致性锁定读

  - 就是在操作的过程中对其进行加锁，如：
  - select*from table for update
  - select*from table in share mode

- 行锁的三种算法

  - record Lock：单个行记录上的锁。

    会去锁该记录的索引，假如没有建立就会用隐式主键进行锁定。

  - Gap Lock：间隙锁，锁定一个范围，但是不含记录本身。

  - Next-Key Lock：锁定一个范围，并锁定记录本身。

    - 当查询的索引具有唯一属性时，innodb就会对其进行优化，降低为 record lock。

- innodb对锁的管理是基于位图的形式，因此锁的开销通常是一致的。

