[TOC]

### 1、死锁产生的条件，怎么解除死锁

- 互斥条件：一个资源只能被一个进程使用
- 请求与保持条件：一个进因请求资源而阻塞时，对已经获得的资源保持不放。
- 不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相连的循环等待关系。

- 
- 预防死锁：破坏四个必要条件中的一个
- 避免死锁：在资源动态分配的过程中，用某种方式不让系统进入不安全的状态。
- 检测死锁：运行时产生死锁，及时发现死锁，让程序跑出来
- 解除死锁，发生死锁后，撤销进程，回收资源，分配给阻塞状态的进程。



- 预防死锁的方法：
  - 破坏请求和保持条件：1.一次性申请所有的资源，之后不再申请资源. 2.只获得初期资源运行，之后将运行完的资源释放，请求新的资源。
  - 破坏不可抢占条件：当一个进程获得某种不可抢占资源，申请其他资源的时候，若获得不了，则释放所有资源。
  - 破坏循环等待条件：对资源进行排号，按照序号递增的方式获得资源，假如拿不到该资源就释放。
- 死锁的解除方法：
  - 抢占资源：从一个或多个进程中，抢占资源分配给死锁进程，以解除死锁状态。
  - 终止进程：将一个或多个死锁进程终止，直至打破循环环路，使系统从死锁状态解脱。

### 2、数据库中锁的种类有几种

- 用来锁定数据库中的对象，如表，页，行。并一般lock的对象只在事务commit或rollback后进行释放。

- 为什么要有锁，一方面要最大程度的利用数据库的并发访问，另一方面又要确保每个用户用以一致的方式读取和修改数据。

  - |          | lock                   | latch              |
    | -------- | ---------------------- | ------------------ |
    | 对象     | 事务                   | 线程               |
    | 保护     | 数据库内容             | 内存数据结构       |
    | 持续时间 | 整个事务过程           | 临界资源           |
    | 模式     | 行锁，表锁，意向锁     | 读写锁，互斥量     |
    | 存在于   | lock manager的哈希表中 | 每个数据结构的对象 |

- innoDB存储引擎实现了如下两种标准的行级锁

  - 共享锁，允许事务读一行数据。
  - 排他锁，允许事务删除或更新一行数据。
  
- innodb不会回滚大多数异常，死锁除外。其他的有超时异常等，有一个参数可以控制等待时间，还有一个参数可以决定是否要超时回滚。

### 3、意向锁===

- 在一个事务对一张表的某行添加S锁之前，它必须对该表获取一个IS锁或者优先级更高的锁。
- 在一个事务对一张表的某行添加X锁之前，它必须对该表获取一个IX锁。

https://blog.csdn.net/zcl_love_wx/article/details/83305645

### 4、什么是快照读，什么是当前读（和下面的一致性非锁定读的内容差不多）===

- 快照读读取的是历史版本，不用加锁。
  - 在RC的事务隔离下，每次快照读，读取的都是最新数据
  - 在RR的事务隔离下，每次快照读，读取的都是事务开始的数据。
- 当前读读取的是最新版本，需要加锁。

### 5、一致性非锁定读（MVCC多版本并发控制）====

- 又叫做快照读，其中快照数据是通过undo段来完成的，而undo用在事务中回滚数据，因此快照数据本身没有额外开销。此外，读取快照不需要上锁，因为没有事务需要对历史数据进行修改操作。
- 该读取方式是innodb的默认读取方式，他不会占用和等待表上的锁。但是再不同事务隔离级别下，读取的方式不同，并不是再每个事务隔离级别下都是采用非锁定的一致性读。
  - 版本链：每一个聚集索引必有两个隐藏的列：trx_id，每次用来修改时的事务id，roll_pointer，每次对哪条聚集索引记录有修改的时候，都会把老版本写入undo日志中，这个roll_pointer就是存了一个指针，它指向这条聚集索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。
  - 读视图：快照读的意思是：每次快照读的时候都会生成一个读视图，该视图是该时刻的一个快照。可重复读和读提交的区别就是，该视图会不会在事务提交后更新，如果是已提交读就会更新，如果是不可重复读就还是第一次那个视图。在RR级别和RC级别的区别。

### 6、一致性锁定读

- SELECT ... FOR UPDATE（+X锁）
- SELECT ... LOCK IN SHARE MODE（+S锁）

### 7、MySQL引擎了解吗？

https://cloud.tencent.com/developer/article/1662516

https://blog.csdn.net/gaohuanjie/article/details/50944782

### 8、事务四大特性

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- 一致性：执行事务前后，数据保持一致，如当回滚的时候，表中字段不唯一。
- 隔离性：并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 9、事务并发带来的问题

- **脏读（Dirty read）:** 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。也就是说读取了还没提交的数据。
- **丢失修改（Lost to modify）:** 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）:** 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
- Mysql技术内幕将幻读和不可重复读归为一类了。

**不可重复度和幻读区别：**

不可重复读的重点是修改，幻读的重点在于新增或者删除。

例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。

例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。

### 10、事务隔离级别

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**
- **READ-COMMITTED(读取已提交):** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**
- **REPEATABLE-READ（可重读）:** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生。**
- **SERIALIZABLE(可串行化):** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。
- MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。我们可以通过`SELECT @@tx_isolation;`命令来查看

### 11、轻量级锁===

- latch，其要求锁定的时间必须非常短，若持续时间长了，则应用的性能会非常差。在InnoDB存储引擎中，latch可分为mutex(互斥锁)和rwlock(读写锁)。
- 目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。

### 11、MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景

- MYISAM的每张表放在三个文件中：表格定义，数据文件，索引文件，而Innodb的所有表都保存在同一个数据文件中。
- InnoDB存储引擎支持事务，其设计目的主要面向在线事务处理的应用。特点是行锁设计，支持外键，默认为REPEATABLE隔离级别，使用next-key locking的策略避免幻读。采用聚集索引。
- MyISAM的索引和数据是分开的，且索引是压缩的，而InnoDB的索引和数据是紧密捆绑的，没有使用压缩，所以Innodb的体积比MyISAM大。
  - MYISAM的叶子节点存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，这样子的索引叫非聚集索引
- MyISAM存储引擎不支持事务，表锁设计，支持全文索引，缓冲区只缓存索引文件。
- 性能上：innodb的删改增性能比MySAM好，而MySAM的查询性能一般比innodb好，
  - Innodb要缓存，而myisam只缓存索引块，这中间还有换进换出的减少。
  - innodb寻址要到块，再到行，Myisam只是文件的偏移量，定位快。
  - Innodb还需要维护MVCC一致性，虽你的场景没有，但他还得去检查和维护mvcc。
- 由于MySAM不支持日志（redo，undo），所以当Mysam的引擎宕机的时候，数据修复困难。
- InnoDB的锁颗粒是行级锁，而MySAM的锁颗粒是表级锁。
- InnoDB中并没有保持总行数，每次select count(*)from table时，都要扫描一遍整个表来计算有几行。而MyISAM不用。

| 引擎   | 特性                                                         |
| ------ | ------------------------------------------------------------ |
| MYISAM | 不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描 |
| INNODB | 支持外键，行锁，查表总行数时，全表扫描                       |

https://blog.csdn.net/Nice07/article/details/83627872

https://blog.csdn.net/weixin_33859504/article/details/88029458

### 12、自适应哈希索引==

- InnoDB监控表上各索引页的查询，如果观察到建立hash索引可以带来速度提升，则建立哈希索引，称为自适应哈希索引。该索引是通过缓冲池的B+树构造而来，因此建立的速度很快，而且不需要对整张表构造哈希索引。

### 13、索引有B+索引和hash索引

- hash的查找比B+索引快。
- 但是hash无法支持范围查找，B+可以。
- hash索引无法进行模糊查询，而B+树木查找的时候可以先查找最左前缀，然后逐步匹配。
- hash容易hash冲突导致链表很长，查找时间加长。

https://blog.csdn.net/qq_44590469/article/details/97877397

### 14.聚集索引和非聚集索引

- 聚集索引和非聚集索引的一个最主要的区别是聚集索引所指向的数据是逻辑连续的，而非聚集索引所指向的数据不一定逻辑连续。
- 非聚集索引的叶子节点存放的是主键，因此非聚集索引需要查找多次。
- 非聚集索引相当于在聚集索引的基础上新建了一个索引，所以非聚集索引的查询需要多次查询。

### 15、索引的底层实现

- B+树的实现
- B树的实现

### 16、B树和B+树的区别

- 一棵B+树可以放多少行数据，2kw。

- 由于非叶子节点没用存放数据，B+树单次磁盘调用能查找的信息更多，所以从性能上比B树要好一些，所以也更加适合外部存储。
- B+树查询稳定，而B树查询不稳定。
- 而且由于B+树叶子节点是用链表连接起来的，这样子有利于范围查询。

### 17、Sql的优化

- 索引下推技术：例如一个select*from table where ...=... and ...=...，假如没有索引下推，会先找到符合最where的第一个条件的所有数据，找到后，再去从这些数据里查找第二个条件，假如有了索引下推，也就是将数据在取出索引的过程中就将where中的情况判断好了。
- 覆盖索引：就是当where和select所查询的是联合索引的时候，可以直接使用索引查询而不需要回表。这就是覆盖索引，通过使用覆盖索引，可以减少搜索树的次数，这就是 **覆盖索引**。
- 索引下推和覆盖索引的区别是索引下推是where语句后面的多个字段（二级索引中存放的是主键，所以可以通过主键查找），而覆盖索引是select和where两个的字段为联合索引

### 18、范式了解吗？

- 第一范式：每个字段都是原子性的，也就是说在同一个表中，不会有其他字段与该字段同类。
- 第二范式：在第一范式的基础上消除了部分依赖，也就是说，不会存在X依赖YZ，但是其实可以X依赖Y的情况出现。
- 第三范式：在第二范式的基础上消除了传递依赖，也就是说不会存在A依赖B,B依赖C的情况。

### 19、最左边前缀原理

- 每次查找需要找到最左边的就行了，之后使用叶子节点的亮标进行遍历，直到不满足条件。

### 20、为什么建议主键自增的索引

- 因为每次添加都可以直接在叶子节点的最右边添加，可以避免页分裂：将一个数据页中的内容分为两部分，如果是主键自增的话，直接再申请一个页面就好了。

### 21、意向锁

- 为了让行锁和表锁共存。
- 在A进行行写锁之后，会对该表进行意向排他锁，当事务B去申请表的写锁时就会失败，会被阻塞。

### 22、DELETE、truncate和drop的区别

- DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行回滚操作，只能对table和view。
- TRUNCATE TABLE则一次性从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的，且删除后，该表的索引和所占用的空间会恢复到初始大小。只能对table.
- drop会将该表空间全部释放掉。
- DROP>TRUNCATE>DELETE

### 23、日志

- 逻辑日志：mysql语句。物理日志：数据页变更。

- binlog存储每条变更的SQL语句，通过追加方式。（恢复数据）
  - 复制和恢复数据，主从模式。
  - statement：存储mysql语句，优点不需要复制每一行数据，减少了IO，提高了性能。可能会造成主从数据不一致。
  - row：存储变更的行
  - mixed
- redolog（数据库持久性的实现方式，减少磁盘IO）
  - 因为事务对数据的修改不一定在同一个数据页，同时对数据的持久化是通过磁盘IO的，磁盘IO是一块一块的操作，每次进行写的话，很浪费资源。
  - 记录事务对哪些数据进行了修改，解决性能问题。（文件小且顺序IO）可以小短时间内提交这个文件。对数据的真实修改积累久一些再变动。
  - redolog没必要保存全部，所以进行大小固定，循环写入的方式。
  - 是物理日志，所以恢复比逻辑日志快很多。
- 区别
  - binlog大小可设置采用追加的格式大于的话，新建一个，redolog大小固定，循环写入。
  - redolog是innodb引擎有的，并不是所有引擎都有，binlog是server实现的，每个引擎都可以使用。
  - binlog记录的是update/delete/insert的sql语句，而redo_log记载的是物理修改的内容。
  - redolog是innodb持久性，恢复数据用的，innodb的持久性就是依靠它实现的，而binlog不仅可以恢复数据，还可以主从复制。
  - redolog是每次事务开始的时候记录变更信息，而binlog是在事务提交的时候才记录。
    - 如果redolog失败就回滚，不去写binlog
    - 如果redolog成功，写binlog失败了，就对事务回滚，将binlog删除。
    - 如果都成功，才会是真的成功。
  - redolog先于binlog日志进行记录，这样子才会在宕机之后数据恢复完全。
- undolog
  - 回滚，MVCC
  - 时间修改的时候，不仅记录了redo log，还记录undo log，如果因为事务失败回滚了，那么可以使用undo log进行回滚。
  - undo log主要存储的是逻辑日志，用来回滚的相反操作日志。
