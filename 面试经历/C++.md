[TOC]

### 1、虚函数，纯虚函数虚继承

- 静态多态：编译期间就实现的多态：函数重载：包括普通函数的重载和成员函数的重载，函数模板的使用。

- 虚函数，每个对象在执行构造函数的时候，会自动生成一个指向虚函数表的指针，而这个虚函数表包含着当前类的所有的虚函数包括继承来的虚函数，用函数指针数组的方式存放，换句话说，该数组放的是函数的地址。当派生类构造对象的时候，也会自己生成一个虚函数指针，该函数指向该派生类的虚表，而该虚表中，如果派生类有重写基类的虚函数的时候，该虚表中该函数的地址就会被替换成重写的那个，如果有增加虚函数的话，该表就会多出一个空间来存放新的虚函数的地址。在动态多态的时候，我们如何确定一个基类对象，也就是说派生类地址赋值给基类指针的时候，p->vptr[i]来调用该函数，由于，虚函数相对于每个类家族（这里是自己定义的一个次）也就是说多个派生类有一样的基类的时候），其索引是一样的，但是其指针所指的类对象，不一样，也就导致了其虚函数表指针可能不一样，从而形成了动态多态。
- 纯虚函数是在虚函数的基础下，在其声明行的末尾加上一个=0，目的是让这个类成为抽象类，不可被声明该类对象，而其派生类需要重写该虚函数。
- 虚继承是为了解决交叉继承的情况，也就是B继承A，C继承A，D继承BC，使得声明类的对象中只有一个A基类。

### 2、static关键字

- 局部变量：初始化在静态存储区上，作用域为函数内。当static修饰局部变量的时候，函数返回时，该变量不会消失，编译器一般初始化为0。
- 全局静态变量：初始化在静态存储区上。该变量只对当前作用域有作用。
- 静态函数：该函数只在该文件内可见，其他文件不能引用该函数。
- 类静态成员变量：初始化在静态存储区上。每个类对象共同拥有该变量，因为其是在静态存储区上分配空间，需要在类外初始化具体为数据类型。 类名::变量名=初始值。sizeof不会计算静态成员变量。
- 类静态函数：每个类对象共同拥有一个静态函数，该函数只能操作类内静态变量。没有this指针，也因为没有this指针，该函数也比普通的类函数速度要快。类外定义不用指定static。

### 3、new/delete和malloc/free

- new是先调用operator new函数或者operator new[]分配足够大内存空间，然后调用相应的构造函数来构造对象，之后返回指向该对象的指针，delete的时候会先调用该析构函数，然后再调用operator delete 或者operator delete[]释放空间。而malloc只是申请一个内存空间。
- new从自由存储区为对象分配内存，而malloc在堆上为对象拿。自由存储区是C++基与new操作符号的一个抽象的概念，凡是通过new操作符进行内存申请，该内存也就是自由存储区，而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存分配。
- new和delete是C++运算符，需要编译器支持，而malloc和free是库函数，需要调用库，也需要保证调用函数和返回类型符合语法。
- new成功返回一个指向对象的指针，而malloc只返回一个void*指针，new失败的时候会抛出bac_alloc异常，它不会返回NULL，而malloc会返回NULL。
- new比较安全，因为其返回的是对象类型的指针，直接就与该对象匹配，而malloc需要强制类型。
- new不需要指定大小，它会通过类型信息计算，而malloc就需要显示指出所需内存的尺寸。
- new[]多次调用构造函数来初始化每个数组元素，释放对象时为每个对象调用析构函数。要配合使用。
- new可以调用malloc，而malloc不能调用new
- new和delete可以被重载还有new[]和delete[]，标准库定义了八个。

### 4、Placement new

- C++的new操作符会创建一个对象，他完成两步操作，分配对象内存，调用对象类的构造函数创建对象。
- 应用场景，在进程间使用共享内存的时候。主进程分配共享内容，然后在共享内存上创建C++类对象，然后进程直接attach到这块共享内容，拿到类对象，直接访问类对象的变量和函数。

### 5、C++中指针和引用的区别

- 指针本身是一个变量，它存放其他变量的地址，而引用其实是变量的别名，对引用进行操作其实就是对改变量本身进程操作
- 指针可以有多级，而引用不能有多级。
- 传参的时候，指针本质还是使用值传递，需要解除引用，而引用就是变量本身，可以直接操作。
- 引用需要初始化，而指针可以不用初始化。
- 指针的大小永远是和操作系统有关的，而sizeof引用所绑定的对象有关系。
- 取地址的时候，指针取的是当前指针的地址，而引用取的是所绑定对象的地址。

### 6、结构体struct和共同体union的区别

- struct是多个变量同时存在在一个内存中，而union是多个变量共享同一段内存。
- struct的内存大小是所有的对齐后所有成员长度的总和，而union是sizeof(变量)最大的那个。
- union可以用来转换不同类型的数据，例如一个int转为uint的时候，可以给union中设置两种类型。。。

对齐操作：每个平台上的编译器都有自己的对其系数，或者可以通过预编译命令#pragma pack(n)来改变这系数。怎么对齐：struct中的第一个变量偏移量为0，之后每个成员的偏移量为该成员变量或者#progma pack两者中较小值的整数倍。关闭内存可以通过添加#progma pack(1)或者在类定义之后添加`__attribute__ ((packed))`

为了提高系统性能。他的要求是要求每个变量的地址都能按照是对齐系数的N倍。

### 7、struct和class的区别

- struct的成员默认是公有的，而class的成员默认是私有的。
- 在继承中，struct是公有继承的，而class是私有继承
- class还可用与定义模板参数，而struct不能
- 能不能用{}初始化，如果两者有了构造函数，那么他们都不能用{}构造，如果没有构造函数，struct可，但class得要所有变量都为public才可。

### 8、如何引用一个定义过的全局变量

- 使用头文件
- 二使用extern
- extern"c"表示该部分是使用C去编译的，从而编译器会按照c的编译规则去寻找该代码块，而不是按照C++的编译规则。
- 当extern的是一个字符串数组的时候，需要使用`extern char a[]`来解决这个问题。

### 9、main 函数执行以前，会执行什么代码？

全局对象的构造函数会在main 函数之前执行，比如int a；初始化为0。

### 10、如何使用全局变量

- 要使用全局变量得使用域作用符"::"

### 11、描述进程内存分配方式以及他们的区别

- 当进程运行的时候，操作系统会给该进程分配一段虚拟地址。在linux32位机上一般是2的32次方也就是4GB。
- 从低地址到高地址的分类有：
- 不可访问区，例如空指针一般是存放0的地址，当访问该地址一般是会报错的，因为0地址不可访问。
- 代码区也就是.text地址，用来存放代码。
- 常量存储区也就是.rodata，用来存放常量字符串。
- 静态存储区里面一般分为两个部分，第一个是.data指的是已经初始化了同时初始值不为0，另外一个是.bss是指未初始化的值，一般.bss会在进程开始的时候初始化为0，所以static变量一开始都为0。
- 接下来是堆，一般被malloc，new所用
- 然后是共享库的映射区域，如DLL或者SO库
- 栈区域
- 命令行参数和环境变量
-  操作系统内核区域，是多个进程共享的。



- 在静态存储区，该存储区域在程序编译的时候就写好了，这块内存在程序的整个运行期间都在看。如：全局变量或static变量。

- 在栈上创建，在执行函数时，函数的局部变量存储在该区域，函数执行结束时会释放该存储空间，栈内存分配运算内置于处理器的指令集。栈通过机器指令push和pop对栈上资源进行一个分配和释放。

- 从堆上分配，也叫做动态内存分配。程序在运行时候使用new或malloc申请多少内存，程序员自己负责用free和delete释放。

- 在C\C++中，通常可以把内存理解为4个分区：栈、堆、全局/静态存储区和常量存储区和自由存储区。

  1 栈
          通常是用于那些在编译期间就能确定存储大小的变量的存储区，用于在函数作用域内创建，在离开作用域后自动销毁的变量的存储区。通常是局部变量，函数参数等的存储区。他的存储空间是连续的，两个紧密挨着定义的局部变量，他们的存储空间也是紧挨着的。栈的大小是有限的，通常Visual C++编译器的默认栈的大小为1MB，所以不要定义int a[1000000]这样的超大数组。

  2 堆
          通常是用于那些在编译期间不能确定存储大小的变量的存储区，它的存储空间是不连续的，一般由malloc（或new）函数来分配内存块，并且需要用free（delete）函数释放内存。如果程序员没有释放掉，那么就会出现常说的内存泄漏问题。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。另外需要注意的一点是，堆的大小几乎不受限制，理论上每个程序最大可达4GB。

  3 全局/静态存储区
          和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。

  4 常量存储区
          和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内的常量是全局可见的。这是一块比较特殊的存储区，他们里面存放的是常量，不允许被修改。

  5 程序代码区
  
  ​	存放程序代码
  
  https://blog.csdn.net/jirryzhang/article/details/79518408
  
  [进程内存分配 - insistYuan - 博客园 (cnblogs.com)](https://www.cnblogs.com/coolYuan/p/9228739.html)
  
  #### 进程的内存分配
  
  栈区，由编译器自动分配和释放，存放函数的参数值。
  
  堆区，由程序申请，程序不释放就会造成内存泄漏。
  
  静态存储区（static），存放静态变量，全局变量等，由系统释放。
  
  常量存储区，常量字符串存放在这区域，由系统释放。
  
  程序代码区，存放函数体的二进制代码。
  
  **进程内存分配图**
  
  | **高地址**         **低地址** | **段区名**                   | **解释**                                                     | **内容** |
  | ----------------------------- | ---------------------------- | ------------------------------------------------------------ | -------- |
  | **stack**                     | 栈：局部变量                 | 1、在函数内部定义的局部变量（非static型）2、中断发生时存放的运行环境 |          |
  | **room**                      | 增长空间：堆向上长，栈向下长 | 堆和栈动态变化的空间，1、堆从低地址向上动态增长2、栈从高地址向下动态增长 |          |
  | **heap**                      | 堆：动态分配的内存空间       | 1、程序运行时动态分配的空间，如malloc函数，new等2、动态释放，如free函数，delete等 |          |
  | **other**                     | 其他                         |                                                              |          |
  | **.bss**                      | 未初始化的全局变量区         | 函数外部定义的（全局变量），如1、  int I;2、  static int j;  |          |
  | **.data**                     | 已初始化的全局变量区         | 1、函数外定义的：static int i = 0;2、函数内部定义的：static int j;//编译器自动初始化为0 |          |
  | **.text**                     | 可执行文件                   | 1、程序代码，即当前CPU的二进制机器码2、常量，如const char msg[]=”hello world\n” |          |

### 12、不适用虚函数的话，能否实现多态（隐藏，重载和覆盖）

- 能，通过函数隐藏，函数隐藏是子类重写与父类同名的函数，其参数可一样也可不一样，从而可以实现多态。
- 函数重载是指在同一个作用域内，定义多个同名不同参，不同类型的函数，他的本质是编译器对函数的重命名，将变量类型和顺序添加了进去。
- 函数覆盖是指函数重写了父类中的虚函数且参数个数和参数类型，返回值都一样。
- 函数隐藏是定义了一个与父类名一样的，但是参数不一样的函数或者是与父类名一样且参数也一样但是该函数不是虚函数的情况。
- 隐藏的好处，提醒程序员该类中，该类型的函数没有定义，其二防止程序调用成基类中的同名同参函数。

### 13、const和define的区别

- define是在预处理期间就扩展好了，而const是在编译期间将该变量放到全局变量区里。
- define可以定义函数，而const不能。
- define的对象不能取地址，而const能。
- 不能对define的对象赋值和const的对象。
- 不能sizeof define的对象，可以sizeofconst对象

### 14、const关键字，如何修改一个const变量

- mutable

- #### volatile

```c++
  void change()const{
        int *p=(int*)&z;
        *p=3;
    }
```

### 15、顶层const和底层const

- 顶层const表示指针本身不能改变。
- 底层cosnt表示指针所指的东西不能改变。

- 拷贝的时候顶层const可以被忽略。

例如

```
const int a=0;
int aa=a;
```

### 16、volatile关键字

- 让程序跑去内存读取数据，而不是在寄存器中读，虽然说读取内存比读取寄存器耗时多，但是，避免了因为代码中插入汇编或者因为其他情况修改了内存中数据而造成的数据不同步的情况。

### 17、动态绑定和静态绑定

- 静态类型，程序在编译时期可以确定的类型。
- 动态类型，程序在运行过程才可以确定的类型，动态类型是可变的，静态类型不可变。
- 静态绑定，绑定的是静态类型，函数依赖静态类型。
- 动态绑定，绑定的是动态类型，函数依赖动态类型，只有虚函数才能有动态绑定，其他都是静态绑定。
- 引用也能动态绑定，因为它能指向（绑定）动态对象，从而在运行中可以知道动态对象类型。

### 18、智能指针

- 智能指针的原理就是充分利用RALL（资源获取即初始化），也是就说通过对象构造和释放来管理资源，同时解决抛出异常后无法释放掉内存，造成内存泄漏的情况。

- 主要包括shared_ptr,auto_ptr,week_ptr,unique_ptr

- unique_ptr：只允许基础指针的一个所有者。 可以移到新所有者(具有移动语义)，但不会复制或共享（即我们无法得到指向同一个对象的两个unique_ptr）。 替换已弃用的 auto_ptr。 

  - 为动态申请的内存提供异常安全。
  - 将动态申请内存的所有权传递给某个函数。
  - 从某个函数返回动态申请内存的所有权。
  - 在容器中保存指针。

- shared_ptr：内部有一个计数器来表示该对象有被多少个shared_ptr所指。当没有指针指向该对象的时候，计数器变为零，同时释放掉指针所指向的内存。

  - 使用make_shared或者构造函数创建。

- week_ptr一般是用来结合shared_ptr使用的。该指针提供对一个或多个shared_ptr实例所属对象的访问。但是它不参与引用计数。如果想要观察对象但不需要其保持活动状态，请使用该实例。

  - 用来破坏掉指针的循环引用。即A中有B的对象，B中有A的，这个时候，当AB创建后，AB的计数都是2，当调用其析构函数后，AB的计数会变成1，因为AB里面的BA对象没有被析构。可以将其中一个类内的shared指针变为弱指针。若引用。
  - 它能判断所管理的对象是否已经被释放。

- auto_ptr的坏处，因为它不是基于引用计数实现，所以一个指针在同一时刻只能被一个对象拥有。

  - ```C++
    auto_ptr<string> ps1 (new string ("hello world!\n"));
    auto_ptr<string> ps2;
    ps2 = ps1;
    ```

- 尽量不要赋值，如果使用了，请不要再使用之前的对象。

- 不要当做参数传递。

- 不能放入vector等容器中。

### 19、弱引用和强引用的区别

- 强引用的对象一定活着。
- 弱引用的对象不一定存在。其功能上类似于普通指针，但是它可以知道对象是否被释放了,week_ptr的lock函数可以检查，不存在返回一个空的shared_ptr，存在返回和当前week_ptr相同的shared_ptr指针。

### 20、什么情况下会用拷贝构造函数

- 函数调用参数没有用引用的情况。
- 函数返回为类对象或者引用的情况。
- 用一个对象初始化另外一个对象的情况。

### 21、typedef和define区别

- define是在预处理的时候进行的，也就是将内容进行简单替换，不做正确性检查。typedef在编译时处理，在作用域内给已存在的类型一个别名。

### 22、引用为什么比指针更安全

- 引用在定义的同时必须初始化，从而保证引用的对象是有效的，则指针可以是NULL的。
- 引用一但被初始化后，它不能指向其他的对象，而指针初始化后可以指向其他对象。

### 23、四种强制类型转换

为什么要有强制类型转换控制符，为了让程序员更好明白这个操作是要干嘛的。

- static_cast

  - 可以进行类层次之间的类型转换，当向下转换的时候是不安全的，因为没有动态类型检查
  - 可以进行基本数据类型之间的类型转换
  - 把空指针转换成目标类型的空指针
  - 把任何类型的表达式转为void类型。
  - 不能转换掉const，或者volatile或者unaligned
  - 在相互联系的类之间进行转换。

- const_cast

  - 强制去掉const特性。它得要操作在指针上面。也就是说

  - ```C++
    int a=10;
    const int *pa=&a;
    int *pb=const_cast<int*>(pa);//去掉底层const
    ```

- reinterpret_cast（他不会对从float到int的过程进行截断操作，而是直接二进制拷贝过去，小数和整数的二进制表现形式不一样）

  - 改变指针或引用的类型。
  - 将指针或引用转换为一个足够长度的整形
  - 将整型转换为指针或引用类型
  - 它只是进行比特拷贝。

- dynamic_cast

  - 运行时处理，需要进行运行时类型检查
  - 不能用于内置的基本数据类型的强制转换
  - 成功返回指针类的指针或者引用，失败返回NULL
  - dynamic_cast进行转换，基类中一定有虚函数，否则编译不通过。
  - 向下转换的时候具有类型检查功能比static_cast更安全。
  - **<>里必须为指针或者引用**
  - **该转换的类型中类型必须要有一个虚函数**

[C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast_C语言中文网 (biancheng.net)](http://c.biancheng.net/cpp/biancheng/view/3297.html)

### 24、转移语义和右值引用！！！！！！！

https://www.jianshu.com/p/d19fc8447eaa

- 在移动构造中，被移动的对象会被变成有效但未定义。
- 左值和右值：左值能出现在赋值号的左边，也能出现在右边，而右值只能出现在右边。
- C++中把表达式分为J：纯右值（prvalue），将亡值（xvalue），和左值（lvalue）
- 当赋值号右方是非引用类型的函数返回值时，赋值运算符函数重载决议会挑选参数为一个右值的版本。
- 左值可以通过std::move变成右值引用。
- 右值引用会修改对象的数据，因此右值引用不能和const一起使用。
- 右值引用在C++内部的swap实现上，还运用在unique_ptr上。
- std::move只是单纯讲一个左值转化为了右值。
- https://zhuanlan.zhihu.com/p/347977300

### 25、完美转发！！！！！！

- 用于讲输入的参数原封不动的传递到下一个函数中，或者是下下个函数中。也就是说，如果输入的是左值，传递给下一个函数的参数就是左值，如果是右值，那么传递给下一个函数的参数也是右值。
- 这里forward函数，传进来是啥，出去是啥。

```c++
void func(string &a){
    cout<<a<<endl;
    cout<<"L"<<endl;
}

void func(string &&a){
    cout<<a<<endl;
    cout<<"R"<<endl;
}

int main(int argc, char** argv)
{
    string a,b;
    a="1",b="2";
    string &&c=std::move(a);
    string &d=b;
    func(std::forward<string>(c));

    func(std::forward<string>(b));

    string A("abc");
    string&& Rval = std::move(A);
    string B(Rval);    // this is a copy , not move.
    func(std::forward<string>(A));
    string C(std::forward<string>(Rval));  // move.
    func(std::forward<string>(C));
    cout << A << endl;       /* output "" */
}
```

```c++
template<typename T>
void print(T& t){
    cout << "lvalue" << endl;
}
template<typename T>
void print(T&& t){
    cout << "rvalue" << endl;
}

template<typename T>
void TestForward(T && v){
    print(v);
    print(std::forward<T>(v));
    print(std::move(v));
}

int main(){
    //主要是看前面两个，传入tesstforward的时候使用了引用坍塌。
    TestForward(1);
    int x = 1;
    TestForward(x);
    TestForward(std::forward<int>(x));
    return 0;
}
//以上代码好像可以完成转发？？？
```

### 26、栈和堆的区别

- 栈是用来存放函数参数值，局部变量是由编译器自动分配释放。堆是用new分配的内存块，由程序自动控制，需要程序员手动利用delete释放，如果没有，程序结束后，操作系统自动回收
- 堆的分配需要频繁的new/delete，造成内存空间的不连续，会有大量碎片。
- 堆的生长方式是向上，也就是向着内存地址增加的方向，而栈的方向是向下的，朝着内存地址减少的方向增长。
- 一般来说，在32位的系统下面，堆内存可以达4GB的空间，对于栈来说，默认大小为2M（win）或者8MB（linux)。
- 分配方式不同：堆是动态分配的，栈有静态和动态两种分配方式，静态分配是由分配器完成，而动态分配是由malloc函数进行。当栈的动态分配和堆不同，它的动态分配由编译器进行释放。
- 分配的效率不同：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：如分配专门的寄存器存放栈的地址，压栈和出栈都有专门的指令执行，决定了栈的效率比较高，而堆则是C/C++库函数提供的，机制很复杂。库函数会按照一定的算法进行分配。

### 27、new和malloc以及delete和free是否可以混用

- 当使用的是内置类型时候，delete和free可以混用

- 当使用的是自定义类型的时候

  - 且没有析构函数，delete和malloc可以混用，有[]和[]都相同
    - 有析构函数且是申请一个数组，malloc申请的空间可以用delete和free释放，但是用delete释放不能加上[]
    - 有析构函数且不是申请一个数组，new申请的空间不能用free释放，可以用delete释放，但是释放必须加上[]

### 28、浅谈各种继承

- 类内使用访问表示符号会影响到派生类的访问权限以及使用者的访问权限。
- 在继承过程中使用访问符号标识符会影响到的是该类的权限会在派生类中如何改变。
- 举个例子。

### 29、组合和继承

- 组合低耦合，继承高耦合。
- 组合内部细节对当前对象不可见，继承的内部细节对当前对象是透明的。
- 子类从父类继承的方法编译就确定下来了，所以无法在运行期间改变从父类继承方法的行为。

### 29、C++11特性

- 基于范围的循环语句
- 智能指针
- auto：根据变量自动识别
- lambda：匿名函数
- 空指针nullptr，不同于null，null是直接宏定义，而nullptr是可以转换成任意对象。

### 30、红黑树

**红黑树简介**

- 每个节点只有红色或者只有黑色。
- 树的根节点始终是黑色的。
- 每个叶子节点（NIL）是黑色
- 红色节点的两个儿子节点一定是黑色的。
- 从节点出发到任何一个后代节点的路径上黑色节点的数量一样。

**红黑树查找效率**

平均是log(n)，最坏不会超过2log(n).

**红黑树两个大操作**

- recolor（红色和黑色）
- rotation（旋转）

**插入**

插入先和二叉树一样遍历。

1. 新插入的节点标记为红色
2. 如果X是根节点，则标记为黑色
3. 如果X的parent不是黑色，同时X也不是root
   1. 如果X的uncle（叔叔）是红色（染色）
      1. 将parent和uncle标记为黑色
      2. 将grand parent标记为红色
      3. 让X节点的颜色与X祖父的颜色相同，重复2，3
   2. 如果X的uncle（叔叔）是黑色（旋转）
      1. 左左（P是G的左孩子，并且X是P的左孩子）要把中间提上去：将P变黑色，PP变红，再将P右旋
      2. 左右（P是G的左孩子，并且X是P的右孩子）P是G的左孩子，先将P左旋，就变成了左左的情况
      3. 右右，要把中间提上去，也就是P变黑色，PP变红色，再左旋
      4. 右左，将P右旋，就变成了右右的情况

### ![img](https://upload-images.jianshu.io/upload_images/2392382-edaf96e55f08c198.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

**删除要先查找替换再平衡**

1. 若删除节点无子节点，则直接删除。

2. 若删除节点一个子节点，就要将其子节点替换上去，若其子节点有两个节点，就需要进行场景3

3. 若删除节点两个个子节点，就要找后继节点去替换它。

- 当我们替换之后，替换的那个节点要根据其颜色判断要不要进一步操作。
  - 若该节点为红色，因为对平衡无影响，只需要将该替换节点变为删除节点的颜色就好了。
  - 若该节点为黑色
    - 该节点为父亲节点的左子节点
      - 替换节点的兄弟节点是红色，这种情况下，兄弟节点的父节点和子节点为黑色，那么这时候要将替换节点变成黑色，将父节点变为红色，再将P左旋。。。
      - 替换节点的兄弟节点是黑色，情况复杂，因为不知道其父亲节点和儿子节点情况
        - 替换节点的兄弟节点的右子节点是红色，左边任意颜色：去删除左子树的一个黑色节点，显然左子树的黑色节点少1了，然而，右边子树又是红色节点，那么我们直接向右边子树借个红色节点来补充黑节点，

。。。接下去就emmm看其他人博客吧，这里做一个收集，就不重复造轮子了。

https://www.jianshu.com/p/e136ec79235c这个看插入

https://zhuanlan.zhihu.com/p/22800206这个的删除讲的比较好

### 31、红黑树和AVL树的区别

- AVL是严格的平衡二叉树，也就是所有节点的高度差绝对值不超过1。一般运用在插入与删除次数比较少的情况。如Windows的NT内核。
- 红黑树不会有一条路径比其他路径长出两倍。
- Linux中用红黑树管理进程控制块，用红黑树管理虚拟内存区域。左指针指向相邻的地址虚拟存储区域，右指针指向相邻的高地址存储区域。

### 32、STLunordered_map等

- unordered_map的底层是hash表，访问比较快，但是其添加和删除可能不如map。

### 33、sellect、poll和epoll

- 从时间复杂度上来看select和poll是O(n)，epoll是事件驱动
- 他们都是同步io，因为他们会在读写就绪后把事件就绪后自己负责读写，也就是说这个问题是阻塞的。
- select能放置的文件描述符只有1024个，而poll和epoll就很多了
- select对文件描述符是线性扫描的比较慢，也可以说不管该描述符有没有活跃，都会被轮询，浪费很多时间，同时在拷贝描述符到内核中去的时候，消耗较多
- select和poll的返回都是返回原来的数据，而select能够返回其响应的list链表。

### 34、epoll的触发模式？LT、ET问epoll和select区别。

- ET是边缘触发模式，也就是说当事件发生是只通知一次，事件发生后要一直处理下去。
- LT是水平触发模式，也就是说当事件发生时候，会一直通知，直到事件结束。
- ET的优点：不需要通知许多次浪费资源，效率比LT高，缺点，每次通知都要把事件处理结束，在设计上有些复杂，且容易遗漏事件。
- LT的优点：编程更符合用户直觉，业务层逻辑更简单，缺点：效率比ET低。

### 35、select和epoll适用于什么场景？我说前者适合连接少且活跃的情况，后者适合连接多的情况。

面试官质疑了，然后让我回去再看看。

### 36、迭代器失效了解吗？

- `vector<int> `的插入和删除会造成在该位置之后的迭代器失效，假如插入数据后需要将扩容，之前vector<int>中所有的迭代器都会失效。
- `list<int>`的删除只影响当前迭代器，而插入无影响。

### 37、静态连接和动态连接

- 静态连接就是在编译的过程将数据连接在一起
  - 优点有：运行时比较快，所需要的库都在，简单操作
  - 缺点有：占用多余空间，一个系统有多个进程的时候，同一个库可能在系统中有多份拷贝。当一个模块有改动的时候，需要将整个程序编译一次。
- 动态连接是对符号的重定位推迟到程序运行时才进行。
  - 优点有：解决了静态连接的两个缺点。在运行时重定位，如果多个程序调用同一个库，只需要在内存中维护同一份代码就可以了。当一个模块更新后，只要编译那个模块就可以了。
  - 动态连接主要有两种方式：一种是装载时重定位，但是有可能造成地址难以找到的问题，二是地址与代码无关，也就是说地址放在了数据段上面去了，每次需要该库的时候，先跑该库的数据段去寻找地址。

### 38、STL相关

- 一级空间配置器（大于128字节）
  - 直接用malloc和free配置
- 二级空间配置器
  - 维护了16个链表，每个链表存放的内存大小从8依次加8字节。
  - 查找适合的链表，假如足够，就拿去
  - 假如不够，去内存池找
    - 内存池够了就拿去
    - 不够
      - 假如够一块以上，就分配去，然后将剩余的内存分配掉，再去heap里面分配足够的内存。
      - 假如一块都不够，就把剩余内存放到空闲链表中，再去heap里面分配足够内存，失败了跑链表看看有没有，没有就返回。
    - 假如还是不行，就跑一级空间配置器，有一个函数会出现中断。

### 39、deque

- deque是由一个map还有多个缓冲区构建的。map并不是stl里面的一个map，而是指一个映射缓存区。缓存区上的每一个元素是一个地址分别指向多个缓冲区。
- deque除了有一个指向map缓冲区的指针外，还有指向deque头元素和尾元素所在缓冲区的元素。分别叫做`start`和`finish`。start和finish中分别有四个指针，分别指着：该缓冲区的头尾地址，和头（尾）元素和指向map中指向所在缓冲区地址的指针。
- 它的迭代器比较复杂，会有一个指向当前段头，一个指向当前段尾，一个指向指着当前段的指针，还有指向当前连续空间的的指针。
- clear会保存一个缓存区。
- erase会查看当前缓冲区。

### 40、stack和queue是适配器

### 41、priority_queue的底层是heap，也是一个vector

## C++11特性

### 42、NULLPTR

- C++不允许将void *隐式转换到其他类型。因为这样子会导致重载的时候出现问题

- ```C++
  char *p=NULL;
  void foo(char*);
  void foo(int);
  foo(NULL);//会调用为foo(int)
  ```

- nullptr能转换为任何指针或成员指针的类型。

### 43、auto类型推导和decltype

- 前者不需要一个板子，后者需要一个括号加一个板子。
- 尾返回类型，利用auto关键字将返回类型后置

### 44、区间for迭代，写出和python一样简洁的循环语句。

### 45、override和final

- 前者显式告诉编译器进行重载，编译器将检查基类函数是否存在这样的虚函数，否则无法通过编译。
- 后者是为了防止类被继续继承以及终止虚函数继续重载引入的。

### 46、稳定排序

- **堆排序 、 快速排序 、 希尔排序 、 直接选择**排序 是不稳定的排序算法。
- 基数排序 、 冒泡排序 、 直接插入排序 、 折半插入排序 、 归并排序 是稳定的排序算法。

### 47、几种hash冲突

- 线性探测
  - 假如找不到就向下寻找，假如到了尾端，就从头部继续寻找。时间复杂度较高。假如遇到一段连续的被填充的hash表格，这个时候的复杂度会很大（主集团）。
- 二次探测
  - 假如该位置被使用了，那么我们依次尝试$H+1^2，H+2^2，H+3^2$。
  - 相比其线性探测，能消除主集团，但可能会造成次集团。
- 开链
  - 在每个表格中维护一个list，每次hash冲突就找list上的内容。
- hash的底层有一个质数常量数组，里面包含了28个质数。
- 也有一个函数，可以在该质数常量数组中去寻找大于等于该函数参数的质数。

<<<<<<< HEAD
<<<<<<< HEAD
### 48、如何在main之前执行一段代码

- static类，通过构造函数。

send()它返回的内容
智能指针是线程安全的吗：不是
智能指针
虚函数，多态 
vector的push_back过程：二级配置器
线程的内容

### 48、动态库
=======
=======
>>>>>>> e223dffd0e4b85699b3d7bba7d786743cab03e22
### 48、内联函数

**inline内联函数是C++中的一种特殊函数，它可以像普通函数一样被调用，但是并不通过函数调用的机制而是通过将函数体直接插入调用处来实现的，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。

inline适用的函数有两种：
（1）在类内定义的成员函数；
（2）在类内声明，类外定义的成员函数。

内联函数与宏替换的差异：
（1）宏是由预处理器对宏进行替代，而内联函数是通过编译器来实现的。
（2）内联函数是真正的函数，在用的时候像宏一样展开，取消了函数的参数压栈，减少了调用的开销。
宏定义在使用时只是简单的文本替换，并没有做严格的参数检查，返回值也不能被强制转换为合适的类型，因此宏存在一系列的隐患和局限性。

注意事项：
（1）内联函数是以空间换时间的做法，省去调用函数的额外开销。所以代码很长或者有循环/递归的函数不适宜使用内联。
（2）inline对编译器来说只是一个建议，编译器可以忽略这个建议。
（3）内联函数的函数体内不能含有复杂的结构控制语句，如switch和while，否则编译器将该函数视同普通函数那样产生函数调用代码。
（4）递归函数不能被用来作为内联函数。
（5）内联函数一般适合于只有1-5行语句的小函数，对于一个含有很多语句的大函数，没必要使用内联函数来实现。
（6）内联函数的定义必须出现在内联函数第一次被调用之前。
（7）对内联函数不能进行异常接口声明，就是不能声明可能抛出的异常。**

<<<<<<< HEAD
>>>>>>> e223dffd0e4b85699b3d7bba7d786743cab03e22
=======
>>>>>>> e223dffd0e4b85699b3d7bba7d786743cab03e22
